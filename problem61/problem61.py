"""
Problem 61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
Triangle
P_{3,n}=n(n+1)/2
1, 3, 6, 10, 15, ...

Square
P_{4,n}=n^2
1, 4, 9, 16, 25, ...

Pentagonal
P_{5,n}=n(3n-1)/2
1, 5, 12, 22, 35, ...

Hexagonal
P_{6,n}=n(2n-1)
1, 6, 15, 28, 45, ...

Heptagonal
P_{7,n}=n(5n-3)/2
1, 7, 18, 34, 55, ...

Octagonal
P_{8,n}=n(3n-2)
1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P_{3,127}=8128), square (P_{4,91}=8281), and pentagonal (P_{5,44}=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
"""
from collections import defaultdict
from itertools import product
## only consider 4 digit numbers

## get all 4 digit. numbers of each one
# triangle - 96
# square - 68
# pentagon - 56
# hexagon - 48
# heptagon - 43
# octagon - 40

# method 1 -brute force: find all poss. combinations of 6 -> 96*68*56*48*43*40 => 30,181,294,080 ->30 billion,
# with order considered, x6! ->21,730,531,737,600 => 21 trillion

# method 2: find a fwd compatible list/set for each number.  Then find a cycle
def triangle(n):
    return n*(n+1)//2
def square(n):
    return n*n
def pentagon(n):
    return n*(3*n - 1)//2
def hexagon(n):
    return n*(2*n - 1)
def heptagon(n):
    return n*(5*n - 3)//2
def octagon(n):
    return n*(3*n - 2)


triangle_nums =set()
square_nums =set()
pentagon_nums =set()
hexagon_nums =set()
heptagon_nums =set()
octagon_nums =set()

funcs =[
    (triangle_nums, triangle),
    (square_nums, square),
    (pentagon_nums, pentagon),
    (hexagon_nums, hexagon),
    (heptagon_nums, heptagon),
    (octagon_nums, octagon)
]

for s, f in funcs:
    # get to 4 digit numbers
    n = 1
    num = f(n)
    while len(str(num))<4:
        n+=1
        num = f(n)
    # get to 4 digit numbers
    while len(str(num))==4:
        s.add(num)
        n+=1
        num = f(n)

all_numbers = set.union(*[s[0] for s in funcs])

def is_valid_cycle(cycle:list , types:list[set],check=False):
    ## assume cycle is already numerically valid

    ## brute force
    sets = [set() for _ in types]
    for num in cycle:
        for a,type in zip(sets,types):
            if num in type: a.add(num)

    ##create all possible choices (len(cycle)!)
    for selection in product(*sets):
        if len(set(selection)) == len(types):  return True
    return False

def is_fwd(num1,num2):
    # num1 last 2 dig. match num2: first 2 dig
    return str(num1)[-2:] == str(num2)[0:2]

class Network:
    def __init__(self, edges):
        self.graph = defaultdict(list)
        for u,v in edges:
            self.graph[u].append(v)

    def find_cycle(self,length,types):
        ##
        def dfs(node,path):
            if len(path) == length:
                # check if cycle and valid
                if path[0] in self.graph[node] and is_valid_cycle(path,types):
                    cycles.append(path)
                    return

            if len(path) < length:
                for neighbor in self.graph[node]:
                    if neighbor not in path:
                        dfs(neighbor,path+[neighbor])

        cycles = []
        for start in all_numbers:
            dfs(start,[start])

        c2 = set()
        for c in cycles:
            c2.add(tuple(sorted(c)))
        for _ in c2: print(_)
        print('checksum is:', sum(c2.pop()))

## create all edges for network
edges = []
for num1 in all_numbers:
    for num2 in all_numbers:
        if is_fwd(num1,num2):
            edges.append((num1,num2))

types = [
    triangle_nums,
    square_nums,
    pentagon_nums,
    # hexagon_nums,
    # heptagon_nums,
    # octagon_nums
]

network = Network(edges)
cycles = network.find_cycle(3,types)


